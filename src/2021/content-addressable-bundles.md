<!--
title: Resource loading with Content Addressable Bundles
date: 2021-03-12
author: Hayato Ito (hayato@google.com)
toc: false
-->

This is a strawperson proposal at very early stage, aiming to load multiple
resources efficiently, using a Content-Addressable Bundle, which can link to
other bundles.

This proposal was merged into
[wicg/webpackage](https://github.com/WICG/webpackage/blob/main/explainers/content-addressable-bundles.md) repo.

# Participate

- [WICG/webpackage](https://github.com/WICG/webpackage/issues)

<!-- TOC -->

## Table of Contents

- [Introduction](#introduction)
- [Goals](#goals)
- [Non-Goals](#non-goals)
- [Web Bundle format](#web-bundle-format)
- [Web APIs](#web-apis)
  - [Declarative form](#declarative-form)
    - [Example](#example)
  - [How to Load](#how-to-load)
  - [Navigate to a bundle.](#navigate-to-a-bundle)
- [Cache strategy](#cache-strategy)
- [Considered alternatives](#considered-alternatives)
- [FAQ](#faq)
- [Stakeholder Feedback / Opposition](#stakeholder-feedback--opposition)
- [References & acknowledgements](#references--acknowledgements)

<!-- /TOC -->

# Introduction

- Loading many unbundled resources is still slower in 2021. We concluded that
  [bundling was necessary in 2018](https://v8.dev/features/modules#bundle), and
  our latest local measurement still suggests that.

- The output of JS bundlers (e.g. webpack) doesn't interact well with the HTTP
  cache. They are pretty good tools but configuring them to work in an optimal
  way is tough, and sometimes they're also incompatible with new requirements
  like
  [dynamic bundling](https://github.com/azukaru/progressivef-fetching/blob/master/docs/dynamic-bundling/index.md)
  (e.g. small edit with tree shaking could invalidate everything).

- With JS bundlers, execution needs to wait for the full bytes to come. Ideally
  loading multiple subresources should be able to utilize full streaming and
  parallelization, but that's not possible if all resources are bundled as one
  javascript. (For JS modules execution still needs to be waited for the entire
  tree due to the current
  [deterministic execution model](https://docs.google.com/document/d/1MJK0zigKbH4WFCKcHsWwFAzpU_DZppEAOpYJlIW7M7E/edit#heading=h.5652gd5ks5id))

There is a proposal which aims to address the above issues, called [Subresource
loading with Web Bundles], a new way to load a large number of resources
efficiently using a format that allows multiple resources to be bundled, e.g.
[Web Bundles](https://web.dev/web-bundles/).

With the [Subresource loading with Web Bundles] proposal, developers will write

```html
<link
  rel="webbundle"
  href="https://example.com/dir/subresources.wbn"
  resources="https://example.com/dir/a.js https://example.com/dir/b.js https://example.com/dir/c.png"
/>
```

to tell the browser that subresources specified in `resources` attribute can be
found within the `https://example.com/dir/subresources.wbn` bundle. The browsers
will fetch a bundle, and load resources from the bundle.

However, currently, there is no mechanism to fetch the partial content of the
bundle. Browsers will fetch the entire bundle even if only one of the resources
in the bundle is updated in a server side.

This explainer proposes a new approach on the top of [Subresource loading with
Web Bundles], aiming to achieve build reproducibility and more flexible
cache-ability as well as load multiple resources efficiently, using a
Content-Addressable Bundle, which can link to other bundles.

# Goals

- The proposal aims to treat resources as _immutable_. If a bundle's URL doesn't
  change, we assume the bundle's contents are _exactly_ same. This is not an
  effort by a convention. The proposal aims to _force_ immutability by
  introducing a Content-Addressable Hash, which is conceptually similar to a
  [Git]'s commit ID you might be familiar with. Content-Addressability gives us
  reproducible builds and gives a browser an opportunity to improve their cache
  efficiency.

- Non-opinionated about bundle granularity. There are trade-offs how a site
  composes their resources into bundles in order to balance various factors like
  total bytes transferred, loading latency, or cache granularity. Instead of a
  _all-or-nothing_ bundle, this proposal aims to provide a way to express a
  dependency graph of bundles. The use of bundlers is an established practice in
  Web development. Bundlers, such as webpack, skypack, would know much about how
  related resources are grouped as a bundle, and might want to express their
  intent as a dependency graph of bundles, considering various trade-offs. They
  wouldn't want to lose this information in building an all-or-nothing bundle.

- Bundles can be served from a static content server. The proposal doesn't
  require any smart server, such as dynamically assembling resources into a
  bundle. Bundles should be statistically generated by a bundler and can be
  copied to a static content server.

# Non-Goals

- Although this proposal aims to give a browser an opportunity to improve cache
  efficiency by utilizing immutable nature and a dependency graph of bundles,
  this proposal doesn't define any normative procedure how a browser should
  cache resources. That's up-to a browser, as of now.

- This proposal's current scope is to serve static contents which don't contain
  any personal information. Although nothing prevents us from including such
  personal information, this proposal currently assumes every resources are
  publicly viewable ones.

# Web Bundle format

TODO(hayato): Define a format using [CDDL]. For a while, this section explains a
non-normative _conceptual_ format.

[cddl]: https://datatracker.ietf.org/doc/html/rfc8610

Bundle's URL should be `<main-resource-url>.<hash>.wbn`.

- Example: `https://example.com/app/index.js.abcd.wbn`
- We'll explain how a hash is calculated later.

This proposal extends the [WebBundle Format][web bundles] with a new version
number. The bundle should have the following fields:

1. bundle's hash: `abcd`

   Note: This proposal has not decided which hash functions we should use. This
   section writes down a hash as just 4 characters, however, a hash would be
   much longer in real cases, like 40 characters used in a Git commit ID.

2. bundle's main-resource URL: `https://example.com/app/index.js`

   Note: The current WebBundle format also defines a main-resource URL. Now, a
   main resource URL must be a part of the bundle's URL,
   "`<main-resource-url>.<hash>.wbn`".

3. Resources section, which is conceptually as follows:

| URL                                           | type     | response headers            | body     | hash |
| --------------------------------------------- | -------- | --------------------------- | -------- | ---- |
| ./index.js                                    | inline   | \<encoded response header\> | \<body\> | b0b0 |
| ./foo.js                                      | inline   | \<encoded response header\> | \<body\> | c0c0 |
| ./bar.js                                      | inline   | \<encoded response header\> | \<body\> | d0d0 |
| https://cdn.example.com/date-util.js.f1f2.wbn | external | NA                          | NA       | f1f2 |

- A resource's URL is either relative or absolute. If a URL is relative, we call
  it an _inline resource_. If a URL is absolute, we call it an _external
  resource_.
- A relative URL must be resolved with base of `<main-resource-url>`. e.g.

  `./foo.js` is resolved as `https://example.com/app/foo.js`.

  Note: The motivation of using a relative URL for inline resources is to make
  it clear that
  [path restriction](https://w3c.github.io/ServiceWorker/#path-restriction) is
  always met.

- Inline resources must have _response headers_ and _body_.
- External resources must not have _response headers_ nor _body_ (Marked as `NA`
  in the table).
- Each resource must have a _hash_.
- Bundle's main resource must be there and must be an inline resource.
- External resource's URL must be formatted as
  `<external-main-resource>.<hash>.wbn`, which is pointing to an external
  bundle.

  Note that an external resource entry tells a browser that an external resource
  can be found in a linked external bundle. In the example,
  `https://cdn.example.com/date-util.js` can be loaded from
  `https://cdn.example.com/date-util.js.f1f2.wbn`.

- An external resource's URL can be cross-origin to the containing bundle.

- A bundle can have any number of inline resources and any number of external
  resource entries.

A _hash_ must be calculated as follows:

- For an inline resource:

  ```
  resource's hash := hash(hash(`<resource-url>`) + hash(`<canonicalized response headers>`) + hash(`<body>`))
  ```

- For an external resource:

  ```
  resource's hash := external bundle's hash
  ```

- For a bundle:

  ```
  bundle's hash := hash(main-resource-hash + resource0-hash + resource1-hash + ... (for every resources in a bundle))
  ```

  (This implies we calculate a hash recursively if a bundle contains an external
  resource)

  Note: A hash should be changed if a main resource is changed.

We call a bundle which satisfies the above requirements, **Content Addressable
Bundles** ; In short, **CAB**.

These requirements imply that a dependency graph of bundles forms a DAG
(directed acyclic graph). If it has a _cycle_, a hash can't be calculated.

# Web APIs

## Declarative form

Note: Declarative syntax is tentative. We borrow
[\<link\>-based API](https://github.com/WICG/webpackage/blob/main/explainers/subresource-loading.md#link-based-api)
from [Subresource loading with web bundles] proposal for the purpose of the
explanation.

### Example

The page (`https://example.com/app/index.html`):

<!-- prettier-ignore -->
```html
<link rel=webbundle
      href=https://example.com/app/index.js.abcd.wbn
      resources="index.js foo.js bar.js https://cdn.example.com/date.js.f1f2.wbn" >

<script type="module" src="index.js" />
```

The bundle (`https://example.com/app/index.js.abcd.wbn`):

| URL                                           | type     | response headers            | body     | hash |
| --------------------------------------------- | -------- | --------------------------- | -------- | ---- |
| ./index.js                                    | inline   | \<encoded response header\> | \<body\> | b0b0 |
| ./foo.js                                      | inline   | \<encoded response header\> | \<body\> | c0c0 |
| ./bar.js                                      | inline   | \<encoded response header\> | \<body\> | d0d0 |
| https://cdn.example.com/date-util.js.f1f2.wbn | external | NA                          | NA       | f1f2 |

Another bundle (`https://cdn.example.com/date-util.js.f1f2.wbn`) (which is
linked from the `index.js.abcd.wbn`):

| URL              | type   | response headers            | body     | hash |
| ---------------- | ------ | --------------------------- | -------- | ---- |
| ./date-util.js   | inline | \<encoded response header\> | \<body\> | 0808 |
| ./string-util.js | inline | \<encoded response header\> | \<body\> | 0909 |

## How to Load

1. When the HTML page is parsed, a browser records that `index.js`, `foo.js`,
   `bar.js`, and `https://cdn.example.com/date-util.js` can be loaded from the
   bundle.

   Note a relative URL is resolved based on the bundle's URL. For an external
   resource, we use a file-name convention. If the URL ends with
   "`.<hash>.wbn`", the browser removes this suffix and then record the URL.

2. The browser fetches `https://example.com/app/index.js.abcd.wbn`.

3. The browser sees `<script type="module" src="index.js" />` tag. Since
   `index.js` is already noted, the browser must load it from the bundle.
4. Suppose that `index.js`, which is an inline resource in the bundle, has the
   following content:

   ```js
   import * as foo from "./foo.js";
   import * as bar from "./bar.js";
   ...
   ```

   The browser must load `./foo.js` and `./bar.js` from the bundle.

5. Suppose that `foo.js`, which is an line resource in the bundle, has the
   following content:

   ```js
   import * as date from "https://cdn.example.com/date-util.js";
   ...
   ```

   The browser knows `https://cdn.example.com/date-util.js` is an external
   resource and it should be loaded from
   `https://cdn.example.com/date-util.js.f1f2.wbn`. The browser must start to
   fetch `https://cdn.example.com/date-util.js.f1f2.wbn`.

6. The browser must parse the index section of the bundle, and record a list of
   resource's URLs.

7. After recorded, the browser loads the main resource, `date-util.js`, from the
   bundle. If `date-util.js` depends on `./string-util.js`, `./string-util.js`
   is loaded from the bundle.
8. Continue processing...

Notes:

- The browser must validate a fetched bundle's hash integrity, and let a
  resource loading fail if the bundle is invalid.
- The browser can cache a bundle by its Content-Addressable hash, and free to
  load a bundle from the cache, instead of from the network.
- The browser may prefetch an external resource bundle as long as a semantics
  doesn't change. The browser should be careful not to record resource entries
  listed in a prefetched bundle too early.

## Navigate to a bundle

In the previous example, we use `<link>`-based API to declare a starting _node_
and its index information, as a _bootstrap_, however, if a browser supports
_Navigate to a bundle_ feature, we don't need such a declarative form in HTML.

For example, given that a bundle, `https://example.com/app/index.html.0101.wbn`,
whose main resource is HTML file:

| URL                                           | type     | response headers            | body     | hash |
| --------------------------------------------- | -------- | --------------------------- | -------- | ---- |
| ./index.html (main-resource)                  | inline   | \<encoded response header\> | \<body\> | 0101 |
| ./index.js                                    | inline   | \<encoded response header\> | \<body\> | b0b0 |
| ./foo.js                                      | inline   | \<encoded response header\> | \<body\> | c0c0 |
| ./bar.js                                      | inline   | \<encoded response header\> | \<body\> | d0d0 |
| https://cdn.example.com/date-util.js.f1f2.wbn | external | NA                          | NA       | f1f2 |

If a browser supports entering `https://example.com/app/index.html.0101.wbn` URL
_directly_ in its address bar, `./index.html` doesn't have to declare resources.
The browser can know them from the bundle's index section, before starting to
parse `index.html` file.

# Cache strategy

It's up-to browsers how to cache bundles. This explainer doesn't define any
formal procedure, however, there are several possible approaches:

- The browser might want to store a dependency graph of bundles in its cache
  storage, using some preferable data structures so that the browser can
  traverse a DAG efficiently.

- If the browser wants to prefetch external resource bundles, the browser can
  traverse a DAG and start to prefetch a missing _node_.

  For example, when the page declares a `bundle-A`, the browser can know its
  hash immediately, and start to traverse a DAG, starting `bunble-A` node, which
  can be looked up by its hash in the browsers' cache storage.

  For example, if the browser has the following DAG, the browser starts to
  prefetch `bundle-D` immediately.

  ```
  bundle-A
  ├── bundle-B
  └── bundle-C
      ├── bundle-D  (missing in the cache storage)
      └── bundle-E
  ```

- If the browser wants to save the cache storage space, the browser might want
  to store only index sections of bundles, which are good enough to traverse
  DAG, and doesn't store the bodies of inline resources because _body_ might be
  space-consuming.

  For example, given that browser has the following dependency graph of bundles,
  where the bodies of `bundle-C`, `bundle-D`, `bundle-E` are missing, the
  browser can start to fetch them again, possibly in parallel, without waiting
  fetching `bundle-C`.

  ```
  bundle-A
  ├── bundle-B
  └── bundle-C (body is missing)
      ├── bundle-D (body is missing)
      └── bundle-E (body is missing)
  ```

- Individual inline resources in a bundle must not interfere a browser's HTTP
  Cache of its resolved URL.

  For example, an inline resource, `./index.js`, in the bundle,
  `https://example.com/app/index.js.abcd.wbn`, and
  `https://example.com/app/index.js` must be treated separately, in terms of
  caching.

# Considered alternatives

TODO(hayato): Add pros and cons

- [Resource Bundles]
- [Dynamic bundle serving with Web Bundles]

# FAQ

TODO(hayato): Add FAQ

# Stakeholder Feedback / Opposition

Not yet.

# References & acknowledgements

- [Get started with Web Bundles]
- [Web Bundles]
- [Subresource Loading with Web Bundles]
- [Resource Bundles]
- [Bundling for the Web]
- [Dynamic bundle serving with Web Bundles]
- [NixOS]
- [Cargo]

[git]: https://git-scm.com/
[get started with web bundles]: https://web.dev/web-bundles/
[wicg/webpackage]: https://github.com/WICG/webpackage
[subresource loading with web bundles]:
  https://github.com/WICG/webpackage/blob/main/explainers/subresource-loading.md
[resource bundles]: https://github.com/WICG/resource-bundles
[bundling for the web]: https://lowentropy.net/posts/bundles/
[web bundles]:
  https://wicg.github.io/webpackage/draft-yasskin-wpack-bundled-exchanges.html
[dynamic bundle serving with web bundles]:
  https://docs.google.com/document/d/11t4Ix2bvF1_ZCV9HKfafGfWu82zbOD7aUhZ_FyDAgmA/edit
[nixos]: https://nixos.org/
[cargo]: https://doc.rust-lang.org/cargo/
